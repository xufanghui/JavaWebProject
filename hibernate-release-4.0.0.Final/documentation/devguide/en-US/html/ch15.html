<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 15. Envers</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Hibernate Developer Guide"/><link rel="up" href="index.html" title="Hibernate Developer Guide"/><link rel="prev" href="ch14.html" title="Chapter 14. JMX"/><link rel="next" href="pr02.html" title="Preface"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="ch14.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="pr02.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4749"/>Chapter 15. Envers</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch15.html#d0e4757">15.1. Basics</a></span></dt><dt><span class="section"><a href="ch15.html#d0e4792">15.2. Configuration</a></span></dt><dt><span class="section"><a href="ch15.html#d0e4988">15.3. Additional mapping annotations</a></span></dt><dt><span class="section"><a href="ch15.html#d0e5035">15.4. Choosing an audit strategy</a></span></dt><dt><span class="section"><a href="ch15.html#envers-revisionlog">15.5. Revision Log</a></span></dt><dd><dl><dt><span class="section"><a href="ch15.html#envers-tracking-modified-entities-revchanges">15.5.1. Tracking entity names modified during revisions</a></span></dt></dl></dd><dt><span class="section"><a href="ch15.html#envers-queries">15.6. Queries</a></span></dt><dd><dl><dt><span class="section"><a href="ch15.html#entities-at-revision">15.6.1. Querying for entities of a class at a given revision</a></span></dt><dt><span class="section"><a href="ch15.html#revisions-of-entity">15.6.2. Querying for revisions, at which entities of a given class changed</a></span></dt><dt><span class="section"><a href="ch15.html#envers-tracking-modified-entities-queries">15.6.3. Querying for entities modified in a given revision</a></span></dt></dl></dd><dt><span class="section"><a href="ch15.html#d0e5431">15.7. Conditional auditing</a></span></dt><dt><span class="section"><a href="ch15.html#d0e5469">15.8. Understanding the Envers Schema</a></span></dt><dt><span class="section"><a href="ch15.html#envers-generateschema">15.9. Generating schema with Ant</a></span></dt><dt><span class="section"><a href="ch15.html#envers-mappingexceptions">15.10. Mapping exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="ch15.html#d0e5541">15.10.1. What isn't and will not be supported</a></span></dt><dt><span class="section"><a href="ch15.html#d0e5561">15.10.2. What isn't and <span class="emphasis"><em>will</em></span> be supported</a></span></dt><dt><span class="section"><a href="ch15.html#d0e5571">15.10.3. <code class="literal">@OneToMany</code>+<code class="literal">@JoinColumn</code></a></span></dt></dl></dd><dt><span class="section"><a href="ch15.html#envers-partitioning">15.11. Advanced: Audit table partitioning</a></span></dt><dd><dl><dt><span class="section"><a href="ch15.html#envers-partitioning-benefits">15.11.1. Benefits of audit table partitioning</a></span></dt><dt><span class="section"><a href="ch15.html#envers-partitioning-columns">15.11.2. Suitable columns for audit table partitioning</a></span></dt><dt><span class="section"><a href="ch15.html#envers-partitioning-example">15.11.3. Audit table partitioning example</a></span></dt></dl></dd><dt><span class="section"><a href="ch15.html#envers-links">15.12. Envers links</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4757"/>15.1. Basics</h2></div></div></div><p>
            To audit changes that are performed on an entity, you only need two things: the
            <code class="literal">hibernate-envers</code> jar on the classpath and an <code class="literal">@Audited</code> annotation
            on the entity.
        </p><p>
            And that's all - you can create, modify and delete the entites as always. If you look at the generated
            schema for your entities, or at the data persisted by Hibernate, you will notice that there are no changes.
            However, for each audited entity, a new table is introduced - <code class="literal">entity_table_AUD</code>,
            which stores the historical data, whenever you commit a transaction.
        </p><p>
            Instead of annotating the whole class and auditing all properties, you can annotate
            only some persistent properties with <code class="literal">@Audited</code>. This will cause only
            these properties to be audited.
        </p><p>
            The audit (history) of an entity can be accessed using the <code class="literal">AuditReader</code> interface, which
            can be obtained having an open <span class="ERROR">&lt;listeral&gt;EntityManager&lt;/listeral&gt;</span> or <code class="literal">Session</code> via
            the <code class="literal">AuditReaderFactory</code>. See the javadocs for these classes for details on the
            functionality offered.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4792"/>15.2. Configuration</h2></div></div></div><p>
            It is possible to configure various aspects of Hibernate Envers behavior, such as table names, etc.
        </p><div class="table"><a id="d0e4797"/><p class="title"><b>Table 15.1. Envers Configuration Properties</b></p><div class="table-contents"><table summary="Envers Configuration Properties" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Property name</th><th>Default value</th><th>Description</th></tr></thead><tbody><tr><td>
                            <span class="property">org.hibernate.envers.audit_table_prefix</span>
                        </td><td>
                        </td><td>
                            String that will be prepended to the name of an audited entity to create the name of the
                            entity, that will hold audit information.
                        </td></tr><tr><td>
                            <span class="property">org.hibernate.envers.audit_table_suffix</span>
                        </td><td>
                            _AUD
                        </td><td>
                            String that will be appended to the name of an audited entity to create the name of the
                            entity, that will hold audit information. If you audit an entity with a table name Person,
                            in the default setting Envers will generate a <code class="literal">Person_AUD</code> table to store
                            historical data.
                        </td></tr><tr><td>
                            <span class="property">org.hibernate.envers.revision_field_name</span>
                        </td><td>
                            REV
                        </td><td>
                            Name of a field in the audit entity that will hold the revision number.
                        </td></tr><tr><td>
                            <span class="property">org.hibernate.envers.revision_type_field_name</span>
                        </td><td>
                            REVTYPE
                        </td><td>
                            Name of a field in the audit entity that will hold the type of the revision (currently,
                            this can be: add, mod, del).
                        </td></tr><tr><td>
                            <span class="property">org.hibernate.envers.revision_on_collection_change</span>
                        </td><td>
                            true
                        </td><td>
                            Should a revision be generated when a not-owned relation field changes (this can be either
                            a collection in a one-to-many relation, or the field using "mappedBy" attribute in a
                            one-to-one relation).
                        </td></tr><tr><td>
                            <span class="property">org.hibernate.envers.do_not_audit_optimistic_locking_field</span>
                        </td><td>
                            true
                        </td><td>
                            When true, properties to be used for optimistic locking, annotated with
                            <code class="literal">@Version</code>, will be automatically not audited (their history won't be
                            stored; it normally doesn't make sense to store it).
                        </td></tr><tr><td>
                            <span class="property">org.hibernate.envers.store_data_at_delete</span>
                        </td><td>
                            false
                        </td><td>
                            Should the entity data be stored in the revision when the entity is deleted (instead of only
                            storing the id and all other properties as null). This is not normally needed, as the data is
                            present in the last-but-one revision. Sometimes, however, it is easier and more efficient to
                            access it in the last revision (then the data that the entity contained before deletion is
                            stored twice).
                        </td></tr><tr><td>
                            <span class="property">org.hibernate.envers.default_schema</span>
                        </td><td>
                            null (same schema as table being audited)
                        </td><td>
                            The default schema name that should be used for audit tables. Can be overridden using the
                            <code class="literal">@AuditTable(schema="...")</code> annotation. If not present, the schema will
                            be the same as the schema of the table being audited.
                        </td></tr><tr><td>
                            <span class="property">org.hibernate.envers.default_catalog</span>
                        </td><td>
                            null (same catalog as table being audited)
                        </td><td>
                            The default catalog name that should be used for audit tables. Can be overridden using the
                            <code class="literal">@AuditTable(catalog="...")</code> annotation. If not present, the catalog will
                            be the same as the catalog of the normal tables.
                        </td></tr><tr><td>
                            <span class="property">org.hibernate.envers.audit_strategy</span>
                        </td><td>
                            org.hibernate.envers.strategy.DefaultAuditStrategy
                        </td><td>
                            The audit strategy that should be used when persisting audit data. The default stores only
                            the revision, at which an entity was modified. An alternative, the
                            <code class="literal">org.hibernate.envers.strategy.ValidityAuditStrategy</code> stores both the
                            start revision and the end revision. Together these define when an audit row was valid,
                            hence the name ValidityAuditStrategy.
                        </td></tr><tr><td>
                            <span class="property">org.hibernate.envers.audit_strategy_validity_end_rev_field_name</span>
                        </td><td>
                            REVEND
                        </td><td>
                            The column name that will hold the end revision number in audit entities. This property is
                            only valid if the validity audit strategy is used.
                        </td></tr><tr><td>
                            <span class="property">org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</span>
                        </td><td>
                            false
                        </td><td>
                            Should the timestamp of the end revision be stored, until which the data was valid, in
                            addition to the end revision itself.  This is useful to be able to purge old Audit records
                            out of a relational database by using table partitioning.  Partitioning requires a column
                            that exists within the table.  This property is only evaluated if the ValidityAuditStrategy
                            is used.
                        </td></tr><tr><td>
                            <span class="property">org.hibernate.envers.audit_strategy_validity_revend_timestamp_field_name</span>
                        </td><td>
                            REVEND_TSTMP
                        </td><td>
                            Column name of the timestamp of the end revision until which the data was valid.  Only used
                            if the ValidityAuditStrategy is used, and
                            <span class="property">org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</span>
                            evaluates to true
                        </td></tr><tr><td>
                            <span class="property">org.hibernate.envers.track_entities_changed_in_revision</span>
                        </td><td>
                            false
                        </td><td>
                            Should entity types, that have been modified during each revision, be tracked. The default
                            implementation creates <code class="literal">REVCHANGES</code> table that stores entity names
                            of modified persistent objects. Single record encapsulates the revision identifier
                            (foreign key to <code class="literal">REVINFO</code> table) and a string value. For more
                            information refer to <a href="ch15.html#envers-tracking-modified-entities-revchanges" title="15.5.1. Tracking entity names modified during revisions">Section 15.5.1, “Tracking entity names modified during revisions”</a>
                            and <a href="ch15.html#envers-tracking-modified-entities-queries" title="15.6.3. Querying for entities modified in a given revision">Section 15.6.3, “Querying for entities modified in a given revision”</a>.
                        </td></tr></tbody></table></div></div><br class="table-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>
                The following configuration options have been added recently and should be regarded as experimental:
                </p><div class="orderedlist"><ol><li>
                        org.hibernate.envers.track_entities_changed_in_revision
                    </li></ol></div><p>
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4988"/>15.3. Additional mapping annotations</h2></div></div></div><p>
            The name of the audit table can be set on a per-entity basis, using the
            <code class="literal">@AuditTable</code> annotation. It may be tedious to add this
            annotation to every audited entity, so if possible, it's better to use a prefix/suffix.
        </p><p>
            If you have a mapping with secondary tables, audit tables for them will be generated in
            the same way (by adding the prefix and suffix). If you wish to overwrite this behaviour,
            you can use the <code class="literal">@SecondaryAuditTable</code> and
            <code class="literal">@SecondaryAuditTables</code> annotations.
        </p><p>
            If you'd like to override auditing behaviour of some fields/properties in an embedded component, you can use
            the <code class="literal">@AuditOverride(s)</code> annotation on the usage site of the component.
        </p><p>
            If you want to audit a relation mapped with <code class="literal">@OneToMany+@JoinColumn</code>,
            please see <a href="ch15.html#envers-mappingexceptions" title="15.10. Mapping exceptions">Section 15.10, “Mapping exceptions”</a> for a description of the additional
            <code class="literal">@AuditJoinTable</code> annotation that you'll probably want to use.
        </p><p>
            If you want to audit a relation, where the target entity is not audited (that is the case for example with
            dictionary-like entities, which don't change and don't have to be audited), just annotate it with
            <code class="literal">@Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED)</code>. Then, when reading historic
            versions of your entity, the relation will always point to the "current" related entity.
        </p><p>
            If you'd like to audit properties of a superclass of an entity, which are not explicitly audited (which
            don't have the <code class="literal">@Audited</code> annotation on any properties or on the class),
            you can list the superclasses in the <code class="literal">auditParents</code> attribute of the
            <code class="interfacename">@Audited</code> annotation.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5035"/>15.4. Choosing an audit strategy</h2></div></div></div><p>
            After the basic configuration it is important to choose the audit strategy that will be used to persist
            and retrieve audit information. There is a trade-off between the performance of persisting and the
            performance of querying the audit information. Currently there two audit strategies.
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                    The default audit strategy persists the audit data together with a start revision. For each row
                    inserted, updated or deleted in an audited table, one or more rows are inserted in the audit
                    tables, together with the start revision of its validity. Rows in the audit tables are never
                    updated after insertion.  Queries of audit information use subqueries to select the applicable
                    rows in the audit tables.  These subqueries are notoriously slow and difficult to index.
                </p></li><li><p>
                    The alternative is a validity audit strategy. This strategy stores the start-revision and the
                    end-revision of audit information. For each row inserted, updated or deleted in an audited table,
                    one or more rows are inserted in the audit tables, together with the start revision of its
                    validity. But at the same time the end-revision field of the previous audit rows (if available)
                    are set to this revision.  Queries on the audit information can then use 'between start and end
                    revision' instead of subqueries as used by the default audit strategy.
                </p><p>
                    The consequence of this strategy is that persisting audit information will be a bit slower,
                    because of the extra updates involved, but retrieving audit information will be a lot faster.
                    This can be improved by adding extra indexes.
                </p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="envers-revisionlog"/>15.5. Revision Log</h2></div><div><h3 class="subtitle">Logging data for revisions</h3></div></div></div><p>
            When Envers starts a new revision, it creates a new <em class="firstterm">revision entity</em> which stores
            information about the revision.  By default, that includes just
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><em class="firstterm">revision number</em> - An integral value (<code class="literal">int/Integer</code> or
                <code class="literal">long/Long</code>).  Essentially the primary key of the revision
            </li><li><em class="firstterm">revision timestamp</em> - either a <code class="literal">long/Long</code> or
                <code class="classname">java.util.Date</code> value representing the instant at which the revision was made.
                When using a <code class="classname">java.util.Date</code>, instead of a <code class="literal">long/Long</code> for
                the revision timestamp, take care not to store it to a column data type which will loose precision.
            </li></ol></div><p>
            Envers handles this information as an entity.  By default it uses its own internal class to act as the
            entity, mapped to the <code class="literal">REVINFO</code> table.
            You can, however, supply your own approach to collecting this information which might be useful to
            capture additional details such as who made a change or the ip address from which the request came.  There
            are 2 things you need to make this work.
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                    First, you will need to tell Envers about the entity you wish to use.  Your entity must use the
                    <code class="interfacename">@org.hibernate.envers.RevisionEntity</code> annotation.  It must
                    define the 2 attributes described above annotated with
                    <code class="interfacename">@org.hibernate.envers.RevisionNumber</code> and
                    <code class="interfacename">@org.hibernate.envers.RevisionTimestamp</code>, respectively.  You can extend
                    from <code class="classname">org.hibernate.envers.DefaultRevisionEntity</code>, if you wish, to inherit all
                    these required behaviors.
                </p><p>
                    Simply add the custom revision entity as you do your normal entities.  Envers will "find it".  Note
                    that it is an error for there to be multiple entities marked as
                    <code class="interfacename">@org.hibernate.envers.RevisionEntity</code>
                </p></li><li><p>
                    Second, you need to tell Envers how to create instances of your revision entity which is handled
                    by the <code class="methodname">newRevision</code> method of the
                    <code class="interfacename">org.jboss.envers.RevisionListener</code> interface.
                </p><p>
                    You tell Envers your custom <code class="interfacename">org.hibernate.envers.RevisionListener</code>
                    implementation to use by specifying it on the
                    <code class="interfacename">@org.hibernate.envers.RevisionEntity</code> annotation, using the
                    <code class="methodname">value</code> attribute. If your <code class="interfacename">RevisionListener</code>
                    class is inaccessible from <code class="interfacename">@RevisionEntity</code> (e.g. exists in a different
                    module), set <span class="property">org.hibernate.envers.revision_listener</span> property to it's fully
                    qualified name. Class name defined by the configuration parameter overrides revision entity's
                    <code class="methodname">value</code> attribute. 
                </p></li></ol></div><pre class="programlisting">@Entity
@RevisionEntity( MyCustomRevisionListener.class )
public class MyCustomRevisionEntity {
    ...
}

public class MyCustomRevisionListener implements RevisionListener {
    public void newRevision(Object revisionEntity) {
        ( (MyCustomRevisionEntity) revisionEntity )...;
    }
}
</pre><p>
            An alternative method to using the <code class="interfacename">org.hibernate.envers.RevisionListener</code>
            is to instead call the <code class="methodname">getCurrentRevision</code> method of the
            <code class="interfacename">org.hibernate.envers.AuditReader</code> interface to obtain the current revision,
            and fill it with desired information.  The method accepts a <code class="literal">persist</code> parameter indicating
            whether the revision entity should be persisted prior to returning from this method. <code class="literal">true</code>
            ensures that the returned entity has access to its identifier value (revision number), but the revision
            entity will be persisted regardless of whether there are any audited entities changed. <code class="literal">false</code>
            means that the revision number will be <code class="literal">null</code>, but the revision entity will be persisted
            only if some audited entities have changed.
        </p><div class="example"><a id="d0e5169"/><p class="title"><b>Example 15.1. Example of storing username with revision</b></p><div class="example-contents"><pre class="programlisting">
                <code class="filename">ExampleRevEntity.java</code>

package org.hibernate.envers.example;

import org.hibernate.envers.RevisionEntity;
import org.hibernate.envers.DefaultRevisionEntity;

import javax.persistence.Entity;

@Entity
@RevisionEntity(ExampleListener.class)
public class ExampleRevEntity extends DefaultRevisionEntity {
    private String username;

    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
}</pre><pre class="programlisting">
                <code class="filename">ExampleListener.java</code>

package org.hibernate.envers.example;

import org.hibernate.envers.RevisionListener;
import org.jboss.seam.security.Identity;
import org.jboss.seam.Component;

public class ExampleListener implements RevisionListener {
    public void newRevision(Object revisionEntity) {
        ExampleRevEntity exampleRevEntity = (ExampleRevEntity) revisionEntity;
        Identity identity =
            (Identity) Component.getInstance("org.jboss.seam.security.identity");

        exampleRevEntity.setUsername(identity.getUsername());
    }
}</pre></div></div><br class="example-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="envers-tracking-modified-entities-revchanges"/>15.5.1. Tracking entity names modified during revisions</h3></div></div></div><p>
                By default entity types that have been changed in each revision are not being tracked. This implies the
                necessity to query all tables storing audited data in order to retrieve changes made during
                specified revision. Envers provides a simple mechanism that creates <code class="literal">REVCHANGES</code>
                table which stores entity names of modified persistent objects. Single record encapsulates the revision
                identifier (foreign key to <code class="literal">REVINFO</code> table) and a string value.
            </p><p>
                Tracking of modified entity names can be enabled in three different ways:
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li>
                    Set <span class="property">org.hibernate.envers.track_entities_changed_in_revision</span> parameter to
                    <code class="literal">true</code>. In this case
                    <code class="classname">org.hibernate.envers.DefaultTrackingModifiedEntitiesRevisionEntity</code> will
                    be implicitly used as the revision log entity.
                </li><li>
                    Create a custom revision entity that extends
                    <code class="classname">org.hibernate.envers.DefaultTrackingModifiedEntitiesRevisionEntity</code> class.
                    <pre class="programlisting">
@Entity
@RevisionEntity
public class ExtendedRevisionEntity
             extends DefaultTrackingModifiedEntitiesRevisionEntity {
    ...
}</pre></li><li>
                    Mark an appropriate field of a custom revision entity with
                    <code class="interfacename">@org.hibernate.envers.ModifiedEntityNames</code> annotation. The property is
                    required to be of <code class="literal">Set&lt;String&gt;</code> type.
                    <pre class="programlisting">
@Entity
@RevisionEntity
public class AnnotatedTrackingRevisionEntity {
    ...

    @ElementCollection
    @JoinTable(name = "REVCHANGES", joinColumns = @JoinColumn(name = "REV"))
    @Column(name = "ENTITYNAME")
    @ModifiedEntityNames
    private Set&lt;String&gt; modifiedEntityNames;
    
    ...
}</pre></li></ol></div><p>
                Users, that have chosen one of the approaches listed above, can retrieve all entities modified in a
                specified revision by utilizing API described in <a href="ch15.html#envers-tracking-modified-entities-queries" title="15.6.3. Querying for entities modified in a given revision">Section 15.6.3, “Querying for entities modified in a given revision”</a>.
            </p><p>
                Users are also allowed to implement custom mechanism of tracking modified entity types. In this case, they
                shall pass their own implementation of
                <code class="interfacename">org.hibernate.envers.EntityTrackingRevisionListener</code> interface as the value
                of <code class="interfacename">@org.hibernate.envers.RevisionEntity</code> annotation.
                <code class="interfacename">EntityTrackingRevisionListener</code> interface exposes one method that notifies
                whenever audited entity instance has been added, modified or removed within current revision boundaries.
            </p><div class="example"><a id="d0e5239"/><p class="title"><b>Example 15.2. Custom implementation of tracking entity classes modified during revisions</b></p><div class="example-contents"><pre class="programlisting">
                    <code class="filename">CustomEntityTrackingRevisionListener.java</code>

public class CustomEntityTrackingRevisionListener
             implements EntityTrackingRevisionListener {
    @Override
    public void entityChanged(Class entityClass, String entityName,
                              Serializable entityId, RevisionType revisionType,
                              Object revisionEntity) {
        String type = entityClass.getName();
        ((CustomTrackingRevisionEntity)revisionEntity).addModifiedEntityType(type);
    }

    @Override
    public void newRevision(Object revisionEntity) {
    }
}</pre><pre class="programlisting">
                    <code class="filename">CustomTrackingRevisionEntity.java</code>

@Entity
@RevisionEntity(CustomEntityTrackingRevisionListener.class)
public class CustomTrackingRevisionEntity {
    @Id
    @GeneratedValue
    @RevisionNumber
    private int customId;

    @RevisionTimestamp
    private long customTimestamp;

    @OneToMany(mappedBy="revision", cascade={CascadeType.PERSIST, CascadeType.REMOVE})
    private Set&lt;ModifiedEntityTypeEntity&gt; modifiedEntityTypes =
                                              new HashSet&lt;ModifiedEntityTypeEntity&gt;();
    
    public void addModifiedEntityType(String entityClassName) {
        modifiedEntityTypes.add(new ModifiedEntityTypeEntity(this, entityClassName));
    }
    
    ...
}
</pre><pre class="programlisting">
                    <code class="filename">ModifiedEntityTypeEntity.java</code>

@Entity
public class ModifiedEntityTypeEntity {
    @Id
    @GeneratedValue
    private Integer id;

    @ManyToOne
    private CustomTrackingRevisionEntity revision;
    
    private String entityClassName;
    
    ...
}
</pre><pre class="programlisting">CustomTrackingRevisionEntity revEntity =
    getAuditReader().findRevision(CustomTrackingRevisionEntity.class, revisionNumber);
Set&lt;ModifiedEntityTypeEntity&gt; modifiedEntityTypes = revEntity.getModifiedEntityTypes()</pre></div></div><br class="example-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="envers-queries"/>15.6. Queries</h2></div></div></div><p>
            You can think of historic data as having two dimension. The first - horizontal -
            is the state of the database at a given revision. Thus, you can
            query for entities as they were at revision N. The second - vertical - are the
            revisions, at which entities changed. Hence, you can query for revisions,
            in which a given entity changed.
        </p><p>
            The queries in Envers are similar to
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.hibernate.org/hib_docs/v3/reference/en/html/querycriteria.html">Hibernate Criteria</a>,
            so if you are common with them, using Envers queries will be much easier.
        </p><p>
            The main limitation of the current queries implementation is that you cannot
            traverse relations. You can only specify constraints on the ids of the
            related entities, and only on the "owning" side of the relation. This however
            will be changed in future releases.
        </p><p>
            Please note, that queries on the audited data will be in many cases much slower
            than corresponding queries on "live" data, as they involve correlated subselects.
        </p><p>
            In the future, queries will be improved both in terms of speed and possibilities, when using the valid-time
            audit strategy, that is when storing both start and end revisions for entities. See
            <a href="">???</a>.
        </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="entities-at-revision"/>15.6.1. Querying for entities of a class at a given revision</h3></div></div></div><p>
                The entry point for this type of queries is:
            </p><pre class="programlisting">AuditQuery query = getAuditReader()
    .createQuery()
    .forEntitiesAtRevision(MyEntity.class, revisionNumber);</pre><p>
                You can then specify constraints, which should be met by the entities returned, by
                adding restrictions, which can be obtained using the <code class="literal">AuditEntity</code>
                factory class. For example, to select only entities, where the "name" property
                is equal to "John":
            </p><pre class="programlisting">query.add(AuditEntity.property("name").eq("John"));</pre><p>
                And to select only entites that are related to a given entity:
            </p><pre class="programlisting">query.add(AuditEntity.property("address").eq(relatedEntityInstance));
// or
query.add(AuditEntity.relatedId("address").eq(relatedEntityId));</pre><p>
                You can limit the number of results, order them, and set aggregations and projections
                (except grouping) in the usual way.
                When your query is complete, you can obtain the results by calling the
                <code class="literal">getSingleResult()</code> or <code class="literal">getResultList()</code> methods.
            </p><p>
                A full query, can look for example like this:
            </p><pre class="programlisting">List personsAtAddress = getAuditReader().createQuery()
    .forEntitiesAtRevision(Person.class, 12)
    .addOrder(AuditEntity.property("surname").desc())
    .add(AuditEntity.relatedId("address").eq(addressId))
    .setFirstResult(4)
    .setMaxResults(2)
    .getResultList();</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="revisions-of-entity"/>15.6.2. Querying for revisions, at which entities of a given class changed</h3></div></div></div><p>
                The entry point for this type of queries is:
            </p><pre class="programlisting">AuditQuery query = getAuditReader().createQuery()
    .forRevisionsOfEntity(MyEntity.class, false, true);</pre><p>
                You can add constraints to this query in the same way as to the previous one.
                There are some additional possibilities:
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                        using <code class="literal">AuditEntity.revisionNumber()</code> you can specify constraints, projections
                        and order on the revision number, in which the audited entity was modified
                    </p></li><li><p>
                        similarly, using <code class="literal">AuditEntity.revisionProperty(propertyName)</code> you can specify constraints,
                        projections and order on a property of the revision entity, corresponding to the revision
                        in which the audited entity was modified
                    </p></li><li><p>
                        <code class="literal">AuditEntity.revisionType()</code> gives you access as above to the type of
                        the revision (ADD, MOD, DEL).
                    </p></li></ol></div><p>
                Using these methods,
                you can order the query results by revision number, set projection or constraint
                the revision number to be greater or less than a specified value, etc. For example, the
                following query will select the smallest revision number, at which entity of class
                <code class="literal">MyEntity</code> with id <code class="literal">entityId</code> has changed, after revision
                number 42:
            </p><pre class="programlisting">Number revision = (Number) getAuditReader().createQuery()
    .forRevisionsOfEntity(MyEntity.class, false, true)
    .setProjection(AuditEntity.revisionNumber().min())
    .add(AuditEntity.id().eq(entityId))
    .add(AuditEntity.revisionNumber().gt(42))
    .getSingleResult();</pre><p>
                The second additional feature you can use in queries for revisions is the ability
                to maximalize/minimize a property. For example, if you want to select the
                revision, at which the value of the <code class="literal">actualDate</code> for a given entity
                was larger then a given value, but as small as possible:
            </p><pre class="programlisting">Number revision = (Number) getAuditReader().createQuery()
    .forRevisionsOfEntity(MyEntity.class, false, true)
    // We are only interested in the first revision
    .setProjection(AuditEntity.revisionNumber().min())
    .add(AuditEntity.property("actualDate").minimize()
        .add(AuditEntity.property("actualDate").ge(givenDate))
        .add(AuditEntity.id().eq(givenEntityId)))
    .getSingleResult();
</pre><p>
                The <code class="literal">minimize()</code> and <code class="literal">maximize()</code> methods return a criteria,
                to which you can add constraints, which must be met by the entities with the
                maximized/minimized properties.
            </p><p>
                You probably also noticed that there are two boolean parameters, passed when
                creating the query. The first one, <code class="literal">selectEntitiesOnly</code>, is only valid when
                you don't set an explicit projection. If true, the result of the query will be
                a list of entities (which changed at revisions satisfying the specified
                constraints).
            </p><p>
                If false, the result will be a list of three element arrays. The
                first element will be the changed entity instance. The second will be an entity
                containing revision data (if no custom entity is used, this will be an instance
                of <code class="literal">DefaultRevisionEntity</code>). The third will be the type of the
                revision (one of the values of the <code class="literal">RevisionType</code> enumeration:
                ADD, MOD, DEL).
            </p><p>
                The second parameter, <code class="literal">selectDeletedEntities</code>, specifies if revisions,
                in which the entity was deleted should be included in the results. If yes, such entities
                will have the revision type DEL and all fields, except the id,
                <code class="literal">null</code>.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="envers-tracking-modified-entities-queries"/>15.6.3. Querying for entities modified in a given revision</h3></div></div></div><p>
                The basic query allows retrieving entity names and corresponding Java classes changed in a specified revision:
            </p><pre class="programlisting">Set&lt;Pair&lt;String, Class&gt;&gt; modifiedEntityTypes = getAuditReader()
    .getCrossTypeRevisionChangesReader().findEntityTypes(revisionNumber);</pre><p>
                Other queries (also accessible from <code class="interfacename">org.hibernate.envers.CrossTypeRevisionChangesReader</code>):
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><em class="firstterm"><code class="methodname">List&lt;Object&gt; findEntities(Number)</code></em>
                    - Returns snapshots of all audited entities changed (added, updated and removed) in a given revision.
                    Executes <code class="literal">n+1</code> SQL queries, where <code class="literal">n</code> is a number of different entity
                    classes modified within specified revision.
                </li><li><em class="firstterm"><code class="methodname">List&lt;Object&gt; findEntities(Number, RevisionType)</code></em>
                    - Returns snapshots of all audited entities changed (added, updated or removed) in a given revision
                    filtered by modification type. Executes <code class="literal">n+1</code> SQL queries, where <code class="literal">n</code>
                    is a number of different entity classes modified within specified revision.
                </li><li><em class="firstterm"><code class="methodname">Map&lt;RevisionType, List&lt;Object&gt;&gt; findEntitiesGroupByRevisionType(Number)</code></em>
                    - Returns a map containing lists of entity snapshots grouped by modification operation (e.g.
                    addition, update and removal). Executes <code class="literal">3n+1</code> SQL queries, where <code class="literal">n</code>
                    is a number of different entity classes modified within specified revision.
                </li></ol></div><p>
                Note that methods described above can be legally used only when default mechanism of
                tracking changed entity names is enabled (see <a href="ch15.html#envers-tracking-modified-entities-revchanges" title="15.5.1. Tracking entity names modified during revisions">Section 15.5.1, “Tracking entity names modified during revisions”</a>).
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5431"/>15.7. Conditional auditing</h2></div></div></div><p>
            Envers persists audit data in reaction to various Hibernate events (e.g. post update, post insert, and
            so on), using a series of even listeners from the <code class="literal">org.hibernate.envers.event</code>
            package. By default, if the Envers jar is in the classpath, the event listeners are auto-registered with
            Hibernate.
        </p><p>
            Conditional auditing can be implemented by overriding some of the Envers event listeners.
            To use customized Envers event listeners, the following steps are needed:
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li>
                Turn off automatic Envers event listeners registration by setting the
                <code class="literal">hibernate.listeners.envers.autoRegister</code>
                Hibernate property to <code class="literal">false</code>.
            </li><li>
                Create subclasses for appropriate event listeners. For example, if you want to conditionally audit
                entity insertions, extend the
                <code class="literal">org.hibernate.envers.eventEnversPostInsertEventListenerImpl</code>
                class. Place the conditional-auditing logic in the subclasses, call the super method if auditing
                should be performed.
            </li><li>
                Create your own implementation of <code class="literal">org.hibernate.integrator.spi.Integrator</code>,
                similar to <code class="literal">org.hibernate.envers.event.EnversIntegrator</code>. Use your event listener
                classes instead of the default ones.
            </li><li>
                For the integrator to be automatically used when Hibernate starts up, you will need to add a
                <code class="literal">META-INF/services/org.hibernate.integrator.spi.Integrator</code> file to your jar.
                The file should contain the fully qualified name of the class implementing the interface.
            </li></ol></div><p>
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5469"/>15.8. Understanding the Envers Schema</h2></div></div></div><p>
            For each audited entity (that is, for each entity containing at least one audited field), an audit table is
            created.  By default, the audit table's name is created by adding a "_AUD" suffix to the original table name,
            but this can be overridden by specifying a different suffix/prefix in the configuration or per-entity using
            the <code class="interfacename">@org.hibernate.envers.AuditTable</code> annotation.
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><p class="title"><b>Audit table columns</b></p><ol><li><p>
                    id of the original entity (this can be more then one column in the case of composite primary keys)
                </p></li><li><p>
                    revision number - an integer.  Matches to the revision number in the revision entity table.
                </p></li><li><p>
                    revision type - a small integer
                </p></li><li><p>
                    audited fields from the original entity
                </p></li></ol></div><p>
            The primary key of the audit table is the combination of the original id of the entity and the revision
            number - there can be at most one historic entry for a given entity instance at a given revision.
        </p><p>
            The current entity data is stored in the original table and in the audit table.  This is a duplication of
            data, however as this solution makes the query system much more powerful, and as memory is cheap, hopefully
            this won't be a major drawback for the users.  A row in the audit table with entity id ID, revision N and
            data D means: entity with id ID has data D from revision N upwards.  Hence, if we want to find an entity at
            revision M, we have to search for a row in the audit table, which has the revision number smaller or equal
            to M, but as large as possible. If no such row is found, or a row with a "deleted" marker is found, it means
            that the entity didn't exist at that revision.
        </p><p>
            The "revision type" field can currently have three values: 0, 1, 2, which means ADD, MOD and DEL,
            respectively. A row with a revision of type DEL will only contain the id of the entity and no data (all
            fields NULL), as it only serves as a marker saying "this entity was deleted at that revision".
        </p><p>
            Additionally, there is a <span class="ERROR">&lt;term&gt;revision entity&lt;/term&gt;</span> table which contains the information about the
            global revision.  By default the generated table is named <span class="database">REVINFO</span> and
            contains just 2 columns: <span class="database">ID</span> and <span class="database">TIMESTAMP</span>.
            A row is inserted into this table on each new revision, that is, on each commit of a transaction, which
            changes audited data.  The name of this table can be configured, the name of its columns as well as adding
            additional columns can be achieved as discussed in <a href="ch15.html#envers-revisionlog" title="15.5. Revision Log">Section 15.5, “Revision Log”</a>.
        </p><p>
            While global revisions are a good way to provide correct auditing of relations, some people have pointed out
            that this may be a bottleneck in systems, where data is very often modified.  One viable solution is to
            introduce an option to have an entity "locally revisioned", that is revisions would be created for it
            independently.  This wouldn't enable correct versioning of relations, but wouldn't also require the
            <span class="database">REVINFO</span> table.  Another possibility is to introduce a notion of
            "revisioning groups": groups of entities which share revision numbering.  Each such group would have to
            consist of one or more strongly connected component of the graph induced by relations between entities.
            Your opinions on the subject are very welcome on the forum! :)
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="envers-generateschema"/>15.9. Generating schema with Ant</h2></div></div></div><p>
            If you'd like to generate the database schema file with the Hibernate Tools Ant task,
            you'll probably notice that the generated file doesn't contain definitions of audit
            tables. To generate also the audit tables, you simply need to use
            <code class="literal">org.hibernate.tool.ant.EnversHibernateToolTask</code> instead of the usual
            <code class="literal">org.hibernate.tool.ant.HibernateToolTask</code>. The former class extends
            the latter, and only adds generation of the version entities. So you can use the task
            just as you used to.
        </p><p>
            For example:
        </p><pre class="programlisting">&lt;target name="schemaexport" depends="build-demo"
  description="Exports a generated schema to DB and file"&gt;
  &lt;taskdef name="hibernatetool"
    classname="org.hibernate.tool.ant.EnversHibernateToolTask"
    classpathref="build.demo.classpath"/&gt;

  &lt;hibernatetool destdir="."&gt;
    &lt;classpath&gt;
      &lt;fileset refid="lib.hibernate" /&gt;
      &lt;path location="${build.demo.dir}" /&gt;
      &lt;path location="${build.main.dir}" /&gt;
    &lt;/classpath&gt;
    &lt;jpaconfiguration persistenceunit="ConsolePU" /&gt;
    &lt;hbm2ddl
      drop="false"
      create="true"
      export="false"
      outputfilename="versioning-ddl.sql"
      delimiter=";"
      format="true"/&gt;
  &lt;/hibernatetool&gt;
&lt;/target&gt;</pre><p>
            Will generate the following schema:
        </p><pre class="programlisting">
    create table Address (
        id integer generated by default as identity (start with 1),
        flatNumber integer,
        houseNumber integer,
        streetName varchar(255),
        primary key (id)
    );

    create table Address_AUD (
        id integer not null,
        REV integer not null,
        flatNumber integer,
        houseNumber integer,
        streetName varchar(255),
        REVTYPE tinyint,
        primary key (id, REV)
    );

    create table Person (
        id integer generated by default as identity (start with 1),
        name varchar(255),
        surname varchar(255),
        address_id integer,
        primary key (id)
    );

    create table Person_AUD (
        id integer not null,
        REV integer not null,
        name varchar(255),
        surname varchar(255),
        REVTYPE tinyint,
        address_id integer,
        primary key (id, REV)
    );

    create table REVINFO (
        REV integer generated by default as identity (start with 1),
        REVTSTMP bigint,
        primary key (REV)
    );

    alter table Person
        add constraint FK8E488775E4C3EA63
        foreign key (address_id)
        references Address;
    </pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="envers-mappingexceptions"/>15.10. Mapping exceptions</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5541"/>15.10.1. What isn't and will not be supported</h3></div></div></div><p>
                Bags (the corresponding Java type is List), as they can contain non-unique elements.
                The reason is that persisting, for example a bag of String-s, violates a principle
                of relational databases: that each table is a set of tuples. In case of bags,
                however (which require a join table), if there is a duplicate element, the two
                tuples corresponding to the elements will be the same. Hibernate allows this,
                however Envers (or more precisely: the database connector) will throw an exception
                when trying to persist two identical elements, because of a unique constraint violation.
            </p><p>
                There are at least two ways out if you need bag semantics:
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                        use an indexed collection, with the <code class="literal">@IndexColumn</code> annotation, or
                    </p></li><li><p>
                        provide a unique id for your elements with the <code class="literal">@CollectionId</code> annotation.
                    </p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5561"/>15.10.2. What isn't and <span class="emphasis"><em>will</em></span> be supported</h3></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                        collections of components
                    </p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5571"/>15.10.3. <code class="literal">@OneToMany</code>+<code class="literal">@JoinColumn</code></h3></div></div></div><p>
                When a collection is mapped using these two annotations, Hibernate doesn't
                generate a join table. Envers, however, has to do this, so that when you read the
                revisions in which the related entity has changed, you don't get false results.
            </p><p>
                To be able to name the additional join table, there is a special annotation:
                <code class="literal">@AuditJoinTable</code>, which has similar semantics to JPA's
                <code class="literal">@JoinTable</code>.
            </p><p>
                One special case are relations mapped with <code class="literal">@OneToMany</code>+<code class="literal">@JoinColumn</code> on
                the one side, and <code class="literal">@ManyToOne</code>+<code class="literal">@JoinColumn(insertable=false, updatable=false</code>)
                on the many side.
                Such relations are in fact bidirectional, but the owning side is the collection (see alse
                <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.jboss.org/hibernate/stable/annotations/reference/en/html_single/#entity-hibspec-collection-extratype">here</a>).
            </p><p>
                To properly audit such relations with Envers, you can use the <code class="literal">@AuditMappedBy</code> annotation.
                It enables you to specify the reverse property (using the <code class="literal">mappedBy</code> element). In case
                of indexed collections, the index column must also be mapped in the referenced entity (using
                <code class="literal">@Column(insertable=false, updatable=false)</code>, and specified using
                <code class="literal">positionMappedBy</code>. This annotation will affect only the way
                Envers works. Please note that the annotation is experimental and may change in the future.
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="envers-partitioning"/>15.11. Advanced: Audit table partitioning</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="envers-partitioning-benefits"/>15.11.1. Benefits of audit table partitioning</h3></div></div></div><p>
                Because audit tables tend to grow indefinitely they can quickly become really large. When the audit tables have grown
                to a certain limit (varying per RDBMS and/or operating system) it makes sense to start using table partitioning.
                SQL table partitioning offers a lot of advantages including, but certainly not limited to:
                </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                            Improved query performance by selectively moving rows to various partitions (or even purging old rows)
                        </p></li><li><p>
                            Faster data loads, index creation, etc.
                        </p></li></ol></div><p>
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="envers-partitioning-columns"/>15.11.2. Suitable columns for audit table partitioning</h3></div></div></div><p>
                Generally SQL tables must be partitioned on a column that exists within the table. As a rule it makes sense to use
                either the <span class="emphasis"><em>end revision</em></span> or the <span class="emphasis"><em>end revision timestamp</em></span> column for
                partioning of audit tables.
                </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
                        End revision information is not available for the default AuditStrategy.
                    </p><p>
                        Therefore the following Envers configuration options are required:
                    </p><p>
                        <code class="literal">org.hibernate.envers.audit_strategy</code> =
                        <code class="literal">org.hibernate.envers.strategy.ValidityAuditStrategy</code>
                    </p><p>
                        <code class="literal">org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</code> =
                        <code class="literal">true</code>
                    </p><p>
                        Optionally, you can also override the default values following properties:
                    </p><p>
                        <code class="literal">org.hibernate.envers.audit_strategy_validity_end_rev_field_name</code>
                    </p><p>
                        <code class="literal">org.hibernate.envers.audit_strategy_validity_revend_timestamp_field_name</code>
                    </p><p>
                        For more information, see <a href="">???</a>.
                    </p></div><p>
            </p><p>
                The reason why the end revision information should be used for audit table partioning is based on the assumption that
                audit tables should be partionioned on an 'increasing level of interestingness', like so:
            </p><p>
                </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                            A couple of partitions with audit data that is not very (or no longer) interesting.
                            This can be stored on slow media, and perhaps even be purged eventually.
                        </p></li><li><p>
                            Some partitions for audit data that is potentially interesting.
                        </p></li><li><p>
                            One partition for audit data that is most likely to be interesting.
                            This should be stored on the fastest media, both for reading and writing.
                        </p></li></ol></div><p>
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="envers-partitioning-example"/>15.11.3. Audit table partitioning example</h3></div></div></div><p>
                In order to determine a suitable column for the 'increasing level of interestingness',
                consider a simplified example of a salary registration for an unnamed agency.
            </p><p>
                Currently, the salary table contains the following rows for a certain person X:

                </p><div class="table"><a id="d0e5706"/><p class="title"><b>Table 15.2. Salaries table</b></p><div class="table-contents"><table summary="Salaries table" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Year</th><th>Salary (USD)</th></tr></thead><tbody><tr><td>2006</td><td>3300</td></tr><tr><td>2007</td><td>3500</td></tr><tr><td>2008</td><td>4000</td></tr><tr><td>2009</td><td>4500</td></tr></tbody></table></div></div><p><br class="table-break"/>
            </p><p>
                The salary for the current fiscal year (2010) is unknown. The agency requires that all changes in registered
                salaries for a fiscal year are recorded (i.e. an audit trail). The rationale behind this is that decisions
                made at a certain date are based on the registered salary at that time. And at any time it must be possible
                reproduce the reason why a certain decision was made at a certain date.
            </p><p>
                The following audit information is available, sorted on in order of occurrence:

                </p><div class="table"><a id="d0e5744"/><p class="title"><b>Table 15.3. Salaries - audit table</b></p><div class="table-contents"><table summary="Salaries - audit table" border="1"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th>Year</th><th>Revision type</th><th>Revision timestamp</th><th>Salary (USD)</th><th>End revision timestamp</th></tr></thead><tbody><tr><td>2006</td><td>ADD</td><td>2007-04-01</td><td>3300</td><td>null</td></tr><tr><td>2007</td><td>ADD</td><td>2008-04-01</td><td>35</td><td>2008-04-02</td></tr><tr><td>2007</td><td>MOD</td><td>2008-04-02</td><td>3500</td><td>null</td></tr><tr><td>2008</td><td>ADD</td><td>2009-04-01</td><td>3700</td><td>2009-07-01</td></tr><tr><td>2008</td><td>MOD</td><td>2009-07-01</td><td>4100</td><td>2010-02-01</td></tr><tr><td>2008</td><td>MOD</td><td>2010-02-01</td><td>4000</td><td>null</td></tr><tr><td>2009</td><td>ADD</td><td>2010-04-01</td><td>4500</td><td>null</td></tr></tbody></table></div></div><p><br class="table-break"/>
            </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="envers-partitioning-example-column"/>15.11.3.1. Determining a suitable partitioning column</h4></div></div></div><p>
                    To partition this data, the 'level of interestingness' must be defined.
                    Consider the following:
                    </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                                For fiscal year 2006 there is only one revision. It has the oldest <span class="emphasis"><em>revision timestamp</em></span>
                                of all audit rows, but should still be regarded as interesting because it is the latest modification
                                for this fiscal year in the salary table; its <span class="emphasis"><em>end revision timestamp</em></span> is null.
                            </p><p>
                                Also note that it would be very unfortunate if in 2011 there would be an update of the salary for fiscal
                                year 2006 (which is possible in until at least 10 years after the fiscal year) and the audit
                                information would have been moved to a slow disk (based on the age of the
                                <span class="emphasis"><em>revision timestamp</em></span>). Remember that in this case Envers will have to update
                                the <span class="emphasis"><em>end revision timestamp</em></span> of the most recent audit row.
                            </p></li><li><p>
                                There are two revisions in the salary of fiscal year 2007 which both have nearly the same
                                <span class="emphasis"><em>revision timestamp</em></span> and a different <span class="emphasis"><em>end revision timestamp</em></span>.
                                On first sight it is evident that the first revision was a mistake and probably uninteresting.
                                The only interesting revision for 2007 is the one with <span class="emphasis"><em>end revision timestamp</em></span> null.
                            </p></li></ol></div><p>

                    Based on the above, it is evident that only the <span class="emphasis"><em>end revision timestamp</em></span> is suitable for
                    audit table partitioning. The <span class="emphasis"><em>revision timestamp</em></span> is not suitable.
                </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="envers-partitioning-example-scheme"/>15.11.3.2. Determining a suitable partitioning scheme</h4></div></div></div><p>
                    A possible partitioning scheme for the salary table would be as follows:
                    </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                                <span class="emphasis"><em>end revision timestamp</em></span> year = 2008
                            </p><p>
                                This partition contains audit data that is not very (or no longer) interesting.
                            </p></li><li><p>
                                <span class="emphasis"><em>end revision timestamp</em></span> year = 2009
                            </p><p>
                                This partition contains audit data that is potentially interesting.
                            </p></li><li><p>
                                <span class="emphasis"><em>end revision timestamp</em></span> year &gt;= 2010 or null
                            </p><p>
                                This partition contains the most interesting audit data.
                            </p></li></ol></div><p>
                </p><p>
                    This partitioning scheme also covers the potential problem of the update of the
                    <span class="emphasis"><em>end revision timestamp</em></span>, which occurs if a row in the audited table is modified.
                    Even though Envers will update the <span class="emphasis"><em>end revision timestamp</em></span> of the audit row to
                    the system date at the instant of modification, the audit row will remain in the same partition
                    (the 'extension bucket').
                </p><p>
                    And sometime in 2011, the last partition (or 'extension bucket') is split into two new partitions:
                    </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                                <span class="emphasis"><em>end revision timestamp</em></span> year = 2010
                            </p><p>
                                This partition contains audit data that is potentially interesting (in 2011).
                            </p></li><li><p>
                                <span class="emphasis"><em>end revision timestamp</em></span> year &gt;= 2011 or null
                            </p><p>
                                This partition contains the most interesting audit data and is the new 'extension bucket'.
                            </p></li></ol></div><p>
                </p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="envers-links"/>15.12. Envers links</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://hibernate.org">Hibernate main page</a>
                </p></li><li><p>
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://community.jboss.org/en/envers?view=discussions">Forum</a>
                </p></li><li><p>
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://opensource.atlassian.com/projects/hibernate/browse/HHH">JIRA issue tracker</a>
                    (when adding issues concerning Envers, be sure to select the "envers" component!)
                </p></li><li><p>
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="irc://irc.freenode.net:6667/envers">IRC channel</a>
                </p></li><li><p>
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.jboss.org/feeds/view/envers">Envers Blog</a>
                </p></li><li><p>
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://community.jboss.org/wiki/EnversFAQ">FAQ</a>
                </p></li></ol></div></div></div><HR xmlns=""/><a xmlns="" href=""><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2011 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="ch14.html"><strong>Prev</strong>Chapter 14. JMX</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="pr02.html"><strong>Next</strong>Preface</a></li></ul></body></html>